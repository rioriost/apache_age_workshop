# Implementation of AGE

## Overview of implemetation

As described on [the top page of Apache AGE](https://age.apache.org), AGE executes the following steps:

1. Parses queries by a function call that uses parser following the [openCypher specification](https://s3.amazonaws.com/artifacts.opencypher.org/openCypher9.pdf).
2. Transforms a Cypher query into a Query tree that will be attached as a subquery node.
3. Understands graph operations and produces plan nodes that are related to graph operations.
4. Executes plan nodes that are related to graph operations.
5. Cypher queries work with PostgreSOL existing fully transactional system (ACID).

## Details

1. Parsing the Cypher Query (openCypher Grammar)

When a Cypher query is submitted (via the `cypher()` function call), Apache AGE first parses the Cypher query string according to the openCypher specification. The extension provides a custom lexer and parser for Cypher: this is implemented in the source file [src/backend/parser/cypher_gram.y](https://github.com/apache/age/blob/master/src/backend/parser/cypher_gram.y) (a Bison grammar for openCypher) along with supporting files like [cypher_clause.c](https://github.com/apache/age/blob/master/src/backend/parser/cypher_clause.c), [cypher_expr.c](https://github.com/apache/age/blob/master/src/backend/parser/cypher_expr.c), etc., which handle various Cypher clauses and expressions. Together, these define the Cypher grammar and construct an internal parse tree (or abstract syntax tree) for the Cypher query. In essence, the **Query Parser** component of AGE “[dissects the Cypher query into its constituent parts, recognizing keywords, nodes, relationships, and patterns](https://dev.to/k1hara/unveiling-the-architecture-of-apache-age-enhancing-postgresql-with-graph-capabilities-5950#:~:text=Query%20Parser%3A%20The%20Query%20Parser,the%20Cypher%20query%20is%20correctly)”.

2. Transforming the Cypher Query into a PostgreSQL Query Tree

After parsing, Apache AGE transforms the Cypher AST into a PostgreSQL query tree (an internal Query structure) which can be planned and executed by the PostgreSQL engine. This happens during the parse analysis/rewriting phase of the SQL statement containing the `cypher()` call. Specifically, Apache AGE hooks into PostgreSQL’s parser analyzer using a `post_parse_analyze_hook`. The extension’s analyzer (implemented in [src/backend/parser/cypher_analyze.c](https://github.com/apache/age/blob/master/src/backend/parser/cypher_analyze.c)) walks the preliminary query tree to find the `cypher()` function call and replaces it in-place with a new subquery that represents the Cypher logic. In other words, the `cypher()` call in the `FROM` clause is transformed into a derived table (`RTE_SUBQUERY`) that contains an equivalent SQL query or plan for the graph pattern.

Internally, the function `convert_cypher_to_subquery` in [cypher_analyze.c](https://github.com/apache/age/blob/master/src/backend/parser/cypher_analyze.c) performs this replacement. It takes the parsed Cypher AST (from step 1), converts it into a Postgres Query structure (composed of `SELECT/FROM/WHERE` as needed to emulate the Cypher semantics), and attaches it to the outer query as a subquery `RangeTblEntry`. At this stage, the Cypher query is essentially translated into a form PostgreSQL can plan: for example, a Cypher `MATCH ... RETURN ...` might become a `SELECT` joining the underlying vertex and edge tables, and a Cypher `CREATE` clause might be represented by a special set-returning function or dummy scan that will be handled later. Notably, the `cypher()` function itself “is a placeholder and never actually runs” at execution – it exists only to carry the Cypher query string into the parser, and is removed during analysis. This design is why the Cypher function arguments (graph name, query string) must be constant and cannot be parameters in a prepared statement (they need to be known and expanded before the execution phase).

3. Planning Graph Operations and Generating Plan Nodes

Once the Cypher has been converted into a PostgreSQL query tree (with possibly some custom nodes or subqueries), the PostgreSQL planner/optimizer takes over. Apache AGE integrates at this stage to handle graph-specific operations in the execution plan. In particular, AGE must plan how to perform graph pattern matching and graph data modifications (creating or deleting vertices/edges) efficiently. The extension uses PostgreSQL’s planner hooks and custom plan node APIs to inject its own plan logic for Cypher clauses.

The primary mechanism here is a planner hook `called set_rel_pathlist_hook` which AGE sets in [src/backend/optimizer/cypher_paths.c](https://github.com/apache/age/blob/master/src/backend/optimizer/cypher_paths.c). This hook allows AGE to examine each relation (subquery or function result) during planning. When the planner encounters the special subquery or function node produced in step 2 for a Cypher clause, AGE’s hook recognizes it (for example, a placeholder for a `CREATE ()` clause or a `_cypher_delete_clause` function) and replaces the regular plan paths with a custom path tailored for that graph operation. For instance, for a Cypher `DELETE` clause, AGE provides a `CustomPath` (defined in [src/backend/optimizer/cypher_pathnode.c](https://github.com/apache/age/blob/master/src/backend/optimizer/cypher_pathnode.c)) that represents the deletion of graph elements; similarly, for a `CREATE` clause, it provides a `CustomPath` for inserting new vertices/edges. These custom path nodes carry along any needed data (like the pattern to create or delete) via their custom_private fields. The relevant code files include [cypher_pathnode.c](https://github.com/apache/age/blob/master/src/backend/optimizer/cypher_pathnode.c) (which defines how to construct these `CustomPath` objects for each type of Cypher clause) and [cypher_createplan.c](https://github.com/apache/age/blob/master/src/backend/optimizer/cypher_createplan.c) (which later turns those paths into executable plan nodes i.e. `CustomScan` nodes). Apache AGE essentially extends the planner to “understand some graph operations” and produce plan nodes for them, rather than treating everything as generic SQL. Normal Cypher pattern matching (e.g. the `JOIN` logic for `MATCH`) is largely handled by the transformed SQL (leveraging PostgreSQL’s existing join planner), but for graph-mutating clauses (`CREATE`, `MERGE`, `DELETE`, `SET`), AGE’s planner hook injects custom plan nodes so it can execute those actions appropriately.

4. Executing the Plan and Graph Operations

With an execution plan finalized (containing some custom plan nodes for graph operations and standard plan nodes for regular SQL parts), the PostgreSQL executor runs the query. Apache AGE integrates at this stage by providing custom executor methods for the graph-related plan nodes. Specifically, each custom plan node introduced in step 3 has corresponding execution code in files like [src/backend/executor/cypher_create.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_create.c), [cypher_delete.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_delete.c), [cypher_merge.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_merge.c), and [cypher_set.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_set.c). These files implement the `CustomScan` interface callbacks (via a `CustomExecMethods` struct) for their respective operations – including functions to initialize, execute, and end the custom scan. For example, the “Cypher Create” plan node uses `begin_cypher_create`, `exec_cypher_create`, and `end_cypher_create` functions in [cypher_create.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_create.c) to actually perform the creation of new vertices or edges during execution.

When the executor drives the plan, it will call `ExecProcNode` on the custom node, which in turn invokes AGE’s `exec_cypher_*` function. These functions typically pull any needed input tuples from their child nodes (e.g., for a `CREATE` based on a `MATCH` pattern, the preceding match results are pulled via `ExecProcNode(lefttree)`) and then perform the graph operation.

During this stage, Apache AGE calls PostgreSQL’s standard heap tuple insertion and deletion routines to modify the underlying storage. AGE stores graph data in two tables per graph (one for vertices and one for edges, typically named `_ag_label_vertex` and `_ag_label_edge` in the graph’s schema). The executor functions will insert or delete records in these tables to reflect changes to the graph. Because the custom plan nodes are integrated into the normal executor, they are scheduled and run in the proper order within the query. The Executor component of AGE thus “interacts directly with the PostgreSQL database engine to retrieve or modify data based on the execution plan”.

5. Integration with PostgreSQL’s ACID Transactions

A major advantage of Apache AGE’s design is that Cypher queries fully participate in PostgreSQL’s ACID-compliant transaction system. Since AGE is an extension (not a fork), it does not implement a separate storage or transaction manager for graph data – instead, all graph data is stored in PostgreSQL tables and all read/write operations go through PostgreSQL’s standard access methods. This means that graph updates (inserts, deletes, property updates) are recorded in PostgreSQL’s WAL (Write-Ahead Log), respect locking protocols, and can be committed or rolled back along with other SQL work. In the source code, there isn’t a single “transaction manager” file for this step; rather, the transaction integration is implicit. For example, when the executor’s `exec_cypher_create` function inserts a new vertex, it ultimately calls PostgreSQL heap insertion routines (through a helper like `insert_entity_tuple` in [cypher_utils.c](https://github.com/apache/age/blob/master/src/backend/executor/cypher_utils.c)), which allocate a new tuple, assign an OID, and record the change in memory – all under the aegis of the current transaction. Only when the surrounding SQL transaction commits will those changes be made durable (via WAL flush); if the transaction aborts, all inserted vertices/edges are automatically rolled back by PostgreSQL. In short, Apache AGE leverages “Postgres’ existing fully transactional system (ACID)” so that graph queries have the same reliability and atomicity as regular SQL.

[Prev: Enablement](02_enablement.md) | [Next: Objects](04_objects.md)
